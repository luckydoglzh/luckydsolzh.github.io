// 题目：
// 给定—个长度为n的整数数组a1，Q2,.…,Qn，以及—个概率数组p1,P2,.…,Pn。
// 定义集合S为一个随机多重集（即集合中的元素可以重复），其构造方式如下：
// 初始时，集合S为空。
// ·对于每个从1到n，我们以概率将α插入到集合S中。注意，每个元素的插入是独立
// 的。
// 定义函数f(S）为集合S中所有元素按位异或的结果。请计算f(S)²的期望值，并输出答案对
// 109+7取模的结果。
// 形式上，设M=109+7，可以证明答案可以表示为不可约分数，其中p和q是整数，且q≠
// 0(mod M)。输出—个整数c，满足0≤<M且·q=p(mod M)。


//思路
//本质上还是状态转移那一套逻辑
//dp[i][j]表示 如果为j时的概率
//那显然分为选/不选两种状态，而且基于前一个状态变化而来，所有i只需要维护两个数组即可
//dp[i][j] = dp[!i][j]*(1-x)
//dp[i][j ^ a[i]] = dp[!i][j] * x



#include<stdio.h>
#define M 1000000007  // 定义模数 M，所有结果都对这个模数取模

int q, n, a[200005], dp[2][1024];  // 定义输入变量和动态规划数组
long long inv, x;

// 快速幂函数，用于计算 a^b % M
long long binpow (long long a, long long b) {
    long long res = 1;  // 初始结果设为1
    // 快速幂算法，通过位移运算计算幂次
    for (; b; a *= a, a %= M, b >>= 1LL) {
        if (b & 1LL)  // 如果当前位为1，则结果乘以当前 a
            res *= a, res %= M;  // 更新结果，并取模
    }
    return res;  // 返回结果
}

void solve() {
    scanf("%d", &n);  // 读取 n 的值
    for (int i = 1; i <= n; i++) 
        scanf("%d", &a[i]);  // 读取数组 a 的值
    
    // 初始化动态规划数组
    for (int i = 0; i < 1024; i++) 
        dp[0][i] = dp[1][i] = 0;  // 清空 dp 数组
    dp[0][0] = 1;  // 初始状态，空集合的异或值为0
    
    long long ans = 0;  // 用于存储最终答案
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &x);  // 读取概率值
        x *= inv;  // 将概率转化为模 M 的形式
        x %= M;
        
        // 清空当前 dp 状态
        for (int j = 0; j < 1024; j++) 
            dp[i & 1][j] = 0;  // 重置当前行
        
        // 更新动态规划数组
        for (int j = 0; j < 1024; j++) {
            // 处理不选择 a[i] 的情况
            dp[i & 1][j] += 1LL * dp[!(i & 1)][j] * (1 - x) % M;
            dp[i & 1][j] += M;  // 确保非负
            dp[i & 1][j] %= M;  // 取模
            
            // 处理选择 a[i] 的情况
            int nval = a[i] ^ j;  // 计算新的异或值
            dp[i & 1][nval] += 1LL * dp[!(i & 1)][j] * x % M;  // 更新新异或值的计数
            dp[i & 1][nval] %= M;  // 取模
        }
    }
    
    // 计算最终答案
    for (int j = 0; j < 1024; j++) {
        ans += 1LL * dp[n & 1][j] * j * j % M;  // 计算 f(S)^2 的期望
        ans %= M;  // 取模
    }
    
    printf("%lld\n", ans);  // 输出最终答案
}

int main() {
    inv = binpow(10000, M - 2);  // 计算 10000 的模逆元
    scanf("%d", &q);  // 读取测试用例数量
    while (q--) 
        solve();  // 处理每个测试用例
}
