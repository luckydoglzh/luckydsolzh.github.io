// Monocarp正在玩一款电脑游戏。他从1级开始。现在他即将遇到n只怪物，按照顺序从第1只到第n
// 只。第i只怪物的等级是a[i]。
// 每只怪物的战斗规则如下：
// 如果Monocarp的等级严格高于怪物的等级，怪物会逃跑（逃走）；
// 否则，Monocarp会和怪物战斗。
// 在战斗中，每经过k次与怪物的战斗（注意，逃跑的怪物不算），Monocarp的等级就会增加1级。因
// 此，当他战斗了k次怪物后，等级会升为2级；战斗了2k次怪物后，等级会升为3级，依此类推。
// 你需要处理q个查询，每个查询的形式是
// ix：如果在这个查询中升级所需的战斗次数为x，Monocarp会和第i只怪物战斗吗？还是这只
// 怪物会逃跑？

//讲一下这道题的思路吧
//本质上如果想不吓跑妖怪，那就要设置足够的k（升级升慢一点），那到底升多少才能满足呢，只要满足前面杀的怪kill_num. killnum / k < a，那就满足要求
//那如果大于a呢，那就不行，得提高k的水平到k1， k1怎么计算呢，k1 = killnum/a + 1
//明白了这个道理我们可以选择用线段树这种数据结构来玩。
//叶子节点表示累积杀的怪，通过父节点往上累计
//遍历每一个怪。 通过头节点来查（k = 0时，左子树杀的怪/k是否小于a，说白了会不会把怪吓跑） (st[i << 1|0)/k+(1<<h)) /*k初始值为0.表示每个怪打了都升一级
//k =0可以的话，继续往左搜，直到等级吼不住了，本质上k也是用二分法逼近得到的
//然后将每次输入值i 和k进行简单换算即可解题

#include <stdio.h>

#define N 200000        // 定义数组的最大大小
#define N_ (1 << 18)    // 定义线段树的基础大小，2^18

int st[N_ * 2], h_, n_; // 线段树数组，h_ 为线段树高度，n_ 为调整后的叶节点数量
//2 1 1 1
// 更新线段树节点值
void update(int i) {
    // 从叶节点位置开始更新（i + n_ 是叶节点在线段树数组中的位置）
    for (i += n_; i > 0; i >>= 1)
        st[i]++; // 更新该节点及其所有祖先节点的值
}

// 查询满足某条件的区间长度
int query(int a) {
    int h, i, s, k;
    
    s = 0, k = 0; // s 记录线段树左子树的总和，k 是区间长度
    for (h = h_ - 1, i = 1; h >= 0; h--) { // 从根节点向下遍历线段树
        // 如果左子树的值加上现有的总和除以区间长度后仍小于 a，则继续向左子树搜索
        if ((s + st[i << 1 | 0]) / (k + (1 << h)) < a)
            i = i << 1 | 0; // 向左子树移动
        else
            s += st[i << 1 | 0], k += 1 << h, i = i << 1 | 1; // 向右子树移动并更新 s 和 k
    }
    return k; // 返回满足条件的区间长度
}

int main() {
    static int aa[N], dp[N]; // aa[] 存储输入的数组，dp[] 存储查询结果
    int n, q, i, k;
    
    // 读入数组长度 n 和查询次数 q
    scanf("%d%d", &n, &q);
    
    // 读入数组 aa[]
    for (i = 0; i < n; i++)
        scanf("%d", &aa[i]);
    
    // 计算线段树的高度 h_，使得线段树的叶节点数不少于 n
    while (1 << h_ < n)
        h_++;
    n_ = 1 << h_; // 确定线段树叶节点的数量为 2^h_
    
    // 初始化 dp[] 数组，并使用 update 函数更新线段树
    for (i = 0; i < n; i++)
        update(dp[i] = query(aa[i])); // 对每个 aa[i] 调用 query 计算 dp[i]，并更新线段树
    
    // 处理每个查询
    while (q--) {
        scanf("%d%d", &i, &k); // 读入查询的索引 i 和目标值 k
        i--; // 将 1 基索引转换为 0 基索引
        
        // 如果 k 大于 dp[i]，输出 "YES"，否则输出 "NO"
        printf(k > dp[i] ? "YES\n" : "NO\n");
    }
    
    return 0;
}
