/**
 * @file
 * @brief 冒泡排序算法
 *
 * 冒泡排序算法的工作原理：
 *
 * 冒泡排序算法是一种简单的排序算法。之所以叫做“冒泡”，是因为在每一轮迭代中，最大的元素被“冒泡”到数组的末尾。这个过程类似于水中气泡向上冒一样。算法的基本思路是通过相邻元素的比较和交换，将最大的元素“冒泡”到数组的末端。通过多轮迭代，直到数组排序完成。
 *
 * 什么是交换（Swap）？
 *
 * 在软件中，交换意味着两个变量的值发生互换。为了执行这个操作，我们需要一个额外的变量。例如，x = 5, y = 10。我们想要将x的值变为10，y的值变为5。可以通过以下步骤实现：
 *
 * int z;
 * z = x;
 * x = y;
 * y = z;
 *
 * 上述过程就是典型的交换过程。通过中间变量z来保存x的原值，完成交换。
 *
 * 冒泡排序算法分析（最好情况 - 最差情况 - 平均情况）
 *
 * 冒泡排序最差情况的时间复杂度是 O(n²)。为什么呢？因为我们计算算法复杂度时，是通过嵌套循环来分析的。n * (n - 1) 乘积给出了 O(n²) 的性能。在最差情况下，所有的循环步骤都会发生。
 * 冒泡排序的平均情况性能也是 O(n²)，因为即使数组部分有序，算法仍然会进行大量的交换操作。
 * 冒泡排序的最好情况性能是 O(n)，但这个情况只能通过优化的冒泡排序算法实现。我们在下面的代码中展示了优化版的冒泡排序。
 */

#include <iostream>
#include <vector>

int main() {
    int n;
    bool swap_check = true;  // 用来标记是否进行交换操作
    std::cout << "请输入要排序的数字个数: ";
    std::cin >> n;  // 用户输入数字的个数
    std::vector<int> numbers;  // 用来存储输入的数字
    std::cout << "请输入 " << n << " 个数字: ";

    // 输入数字
    int num;
    for (int i = 0; i < n; i++) {
        std::cin >> num;  // 用户输入每个数字
        numbers.push_back(num);  // 将每个数字添加到数组中
    }

    // 冒泡排序
    for (int i = 0; (i < n) && (swap_check); i++) {
        swap_check = false;  // 每次迭代时初始化交换标志
        for (int j = 0; j < n - 1 - i; j++) {  // 内循环，每次迭代会“冒泡”出一个最大值
            if (numbers[j] > numbers[j + 1]) {  // 如果当前数字大于下一个数字，则交换
                swap_check = true;  // 标记发生了交换
                std::swap(numbers[j], numbers[j + 1]);  // 交换两个数字
            }
        }
    }

    // 输出排序后的数组
    std::cout << "\n排序后的数组 : ";
    for (int i = 0; i < numbers.size(); i++) {
        if (i != numbers.size() - 1) {
            std::cout << numbers[i] << ", ";  // 如果不是最后一个元素，输出逗号
        } else {
            std::cout << numbers[i] << std::endl;  // 如果是最后一个元素，输出换行符
        }
    }
    return 0;
}
